# _Εργασία 2<sup>ου</sup> Εργαστηρίου Αρχιτεκτονικής Υπολογιστών_

## ΤΗΜΜΥ 2020-2021

## Ομάδα 14

## Συγγραφείς 
- **Κινούς Αλέξανδρος**  
***ΑΕΜ: 8834***

- **Βαλαώρα Βασιλεία**  
***ΑΕΜ: 8657***

## Περιεχόμενα:

> **_Ερώτημα 1_**
>
>    > a) [Εύρεση παραμέτρων για **default** υποσύστημα μνήμης](#εύρεση-παραμέτρων-για-default-υποσύστημα-μνήμης)
>    >
>    > b) 
>    >    > i) [Καταγραφή αποτελεσμάτων **benchmarks** για ***default*** τιμές](#καταγραφή-αποτελεσμάτων-benchmarks-για-default-τιμές)
>    >    >
>    >    > ii) [Γραφική αναπαράσταση των παραπάνω αποτελεμάτων](#Γραφική-Αναπαράσταση-των-παραπάνω-αποτελεμάτων)
>    >    >
>    >    > iii) [Σχολιασμός των παραπάνω αποτελεσμάτων](#Σχολιασμός-των-παραπάνω-αποτελεσμάτων)
>    >
>    > c) [...](#1.c)
>
> **_Ερώτημα 2_**
>
> **_Ερώτημα 3_**

## Εύρεση παραμέτρων για **default** υποσύστημα μνήμης

Γνωρίζουμε από το 1<sup>ο</sup> εργαστήριο ότι για την εύρεση στοιχείων του συστήματος πρέπει να μελετήσουμε τα ***configuration files***, δηλαδή ένα εκ των **config.ini**, **config.json**.

Μελετώντας το **config.ini** έχουμε:

  - Από `[system.cpu.dcache]`, (_line 169_ & _line 152_) : 
   
      **L1 Data Cache**

       > size = 65536 ή **64 KB**   
       > assoc = 2
       
       
  - Από `[system.cpu.icache]`, (_line 833_ & _line 816_) : 
   
      **L1 Instruction Cache**

       > size = 32768 ή **32 KB**    
       > assoc = 2
       
       
       
  - Από `[system.l2]`, (_line 1078_ & _line 1061_) : 
   
      **L2 Cache**

       > size = 2097152 ή **2 MB**    
       > assoc = 8
       
       
       
  - Από `[system]`, (_line 15_) : 
   
      **Cache Line**

       > cache_line_size = **64 B**
       


## Καταγραφή αποτελεσμάτων benchmarks για default τιμές

Για την εύρεση αποτελεσμάτων ή στατιστικών στοιχείων ανατρέχουμε στο αρχείο **stats.txt** του εκάστοτε ***benchmark***.

Έχουμε λοιπόν : 



| | bzip | mcf | hmmer | sjeng | libm |
| :---: | :---: | :---: | :---: | :---: | :---: |
| Execution Time (ms) | 83.654 | 62.553 | 59.390 | 513.823 | 174.763 |
| CPI | 1.673085 | 1.251067 | 1.187803 | 10.276466 | 3.495270 | 
| L1 dCache MissRate (%) | 1.4312 | 0.2062 | 0.1628 | 12.1831 | 6.0972 |
| L1 iCache MissRate (%) | 0.0075 | 1.9032 | 0.0212 | 0.0020 | 0.0095 |
| L2 Cache MissRate  (%)| 29.5247 | 6.7668 | 7.8296 | 99.9978 | 99.9940 |


<br>
<br>

## Γραφική Αναπαράσταση των παραπάνω αποτελεμάτων  
<br>
<br>
<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/Execution%20Time%20(ms).png">
<br>
<br>
<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/CPI.png">
<br>
<br>
<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/L1%20dCache%20MissRate%20(%25).png">
<br>
<br>
<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/L1%20iCache%20MissRate%20(%25).png">
<br>
<br>
<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/L2%20Cache%20MissRate%20(%25).png">




## Σχολιασμός των παραπάνω αποτελεσμάτων
Παρατηρώντας τα παραπάνω γραφήματα, διαπιστώνουμε μια αναλογία μεταξύ του **CPI** (Cycles per Instruction) και των *miss-rate* των **L1 Data Cache** και **L2 Cache**. Αυτό σημαίνει ότι όσο *αυξάνονται* τα miss-rate σε αυτές τις μνήμες cache, *αυξάνεται* και το CPI. Αυτό εξηγείται και από το γεγονός ότι χρεώνεται ένα _"time penalty"_ για κάθε miss-rate που συμβαίνει είτε στην L1 Data Cache είτε στην L2 Cache, με την διαφορά ότι της L2 είναι μεγαλύτερο, λόγω της ***βραδύτητας*** της συγκεκριμένης cache σε σχέση με την L1 Data Cache.  
Από την άλλη, το miss-rate της L1 Instruction Cache δεν επηρεάζει σημαντικά το συνολικό χρόνο εκτέλεσης των προγραμμάτων.


## Στατιστικά με αλλαγή του χρονισμού της cpu στο 1GHz

| | bzip | mcf | hmmer | sjeng | libm |
| :---: | :---: | :---: | :---: | :---: | :---: |
| Execution Time (ms) | 160.3594 | 123.265 | 118.517 | 705.640 | 262.262 |
| CPI | 1.603595 | 1.251067 | 1.185174 | 7.056395 | 2.622616 | 
| L1 dCache MissRate (%) | 1.4123 | 0.2062 | 0.1619 | 12.1831 | 6.0972 |
| L1 iCache MissRate (%) | 0.0075 | 1.9046 | 0.0212 | 0.0020 | 0.0095 |
| L2 Cache MissRate  (%)| 29.5227 | 6.7668 | 7.8295 | 99.9978 | 99.9940 |

<br>
<br>
<br>
<br>

<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/Differentclocks.png">

#### Όπως αναμέναμε υποδιπλασιάζοντας την ταχύτητα του επεξεργαστή αυξήθηκε αρκετά ο χροόνος εκτέλεσης του εκάστοτε benchmark.


Συμβουλευόμενοι το αρχείο **stats.txt**, το ρολόι `system.clk_domain.clock` είναι ρυθμισμένο στο 1 GHz (1000 ticks) και είναι υπεύθυνο για τον χρονισμό του ρολογιού του συστήματος. Από την άλλη, το ρολόι `system.cpu_clk_domain.clock` του επεξεργαστή ειναι **by default** χρονισμένο στα 2GHz (500 ticks).  


<br>
<br>



## Design Exploration



Σε αυτό το βήμα εκτελέσαμε πολλαπλές φορές τα **benchmarks** αλλάζοντας κάθε φορά τις *default* παραμέτρους του επεξεργαστή με σκοπό (για λόγους απλοποίησης) την βελτιστοποίηση του μέσου **CPI**. Επίσης, οι προαναφερθείσες αλλαγές γίνονται με όριο **256 KB** για το μέγεθος της *L1 Cache* και **4 MB** για το μέγεθος της *L2 Cache* .


## L1 dCache Size and Associativity


Παρακάτω παραθέτουμε τα διαγράμματα μεταβολής του μέσου CPI σε 32, 64, 128 KB dCache και 2, 4, 8 dCache associativity.



<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/Dcache_size_assoc.png">

Παρατηρούμε ότι η αύξηση του cache associativity δεν έχει αξιόλογο αντίκτυπο στην μείωση του **Average CPI** οπότε δεδομένου οτι η αλλαγή του associativity θεωρείται ακριβή λόγω του πολυπλέκτη, μάλλον θα αποφασίσουμε να το διατηρήσουμε στην τιμή 2.


Παρακάτω βλέπουμε τα αντίστοιχα διαγράμματα για την iCache.



<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/icachesizeassoc1.png">


Βλέπουμε ότι η διαφορά στο size από 64 KB σε 128 KB και στο associativity απο 4 σε 8 είναι σχεδόν μηδαμινή. 



<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/cache_line_size.png"> 


Η μεγαλύτερη διαφορά ως τώρα παρατηρείται στην μεταβολή του μεγέθους του **Cache Line** που σίγουρα είναι λογικό, διότι όσο περισσότερη η πληροφορία που δέχεται η μνήμη cache τόσο πιο απίθανο είναι να υπάρχουν "misses" και κατά συνέπεια χρονικές απώλειες.




Ας δούμε τώρα πως επηρεάζει η **L2 Cache** την απόδοση του *gem 5*.


<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/Icache_size_assoc.png">

Όσον αφορά στο **size**, πάλι βρισκόμαστε στην περίπτωση, όπου ναι μεν υπάρχει μείωση αλλά δεν είναι αρκετή για να χρειαστεί να αλλάξουμε το configuration.
Η μεταβολή του associativity από την άλλη, όχι απλά δεν "βοηθά" αλλά όπως βλέπουμε είναι και εντελώς αντιπαραγωγική.




## Βέλτιστο δυνατό configuration 

Με βάση τα παραπάνω αποτελέσματα, αν λειτουργήσουμε αποκλειστικά με γνώμονα την μέγιστη απόδοση και μη λαμβάνοντας υποψιν τα κόστη, το βέλτιστο configuration είναι:



| Param | Value |
| :---: | :---: |
| dCache size | 128 KB |
| dCache assoc | 4 |
| iCache size | 64 KB |
| iCache assic | 4 |
| l2 Cache size | 8 MB |
| l2 Cache assoc | 4 |
| Cache Line size | 128 B |


<br>

<br>


<img src="https://github.com/akinous/ArchitectureLab2020/blob/main/Lab2/gem5images/default_cache_opt.png">


<br>

Βλέπουμε πως η διαφορά μεταξύ των maxed out settings και του _απλά να μεταβάλουμε_ το **Cache Line size** είναι της τάξεως του **1.5%**, δηλαδή αμελητέα.

Άρα, ήδη αντιλαμβανόμαστε ότι μια συμφέρουσα λύση είναι να διατηρηθούν όλα τα **default** settings και να μεταβληθεί το **Cache Line size** στα 128 B.



## 3. Ανάλυση κόστους και βελτιστοποίηση 


### Cache size


Αρχικά γνωρίζουμε οτι τοσο η L1 cache οσο και η L2 cache ειναι φτιαγμένες απο **sram**. Βέβαια η L1 cache λόγω της πολυπλοκότητας της και της latency optimized φυσης της καταληγει να ειναι αρκετες ταξεις μεγεθους πιο ακριβη απ την L2 cache . Για τις αναγκες της εργασιας μπορουμε να θεσουμε μια αυθαιρετη μοναδα κοστους **U**. Με βαση την παραπανω σχεση κοστους μεταξυ L1,L2 ειναι λογικο να πουμε οτι 32 kb L1 cache κοστιζουν οσο 2 mb L2 cache δηλαδη 1 U . Επειτα καθε διπλασιασμος του cache size συνεπαγεται μεγαλυτερο και πιο πολυπλοκο hardware αρα σαφεστατα και διπλασιασμο του κοστους. 

Καταληγουμε λοιπόν : 

costL1 = sizeL1 / 32   ,   costL2 = sizeL2 / 2



### Associativity

Η αλλαγη το associativity ουσιαστικα σημαινει αλλαγη του πολυπλεκτη κατι το οποιο δεν ειναι ιδιαιτερα κοστοβορο στις μικρες αλλαγες. Σε μεγαλυτερες φαινεται να αυξανει εντονα τοσο το κοστος του αναγκαιου hardware οσο και το υπολογιστικο κοστος. Για να περιγραψουμε λοιπον το εν λογω κοστος με μια συναρτηση χρειαζομαστε μια που να ειναι αργη στις μικροτερες τιμες και στις μεγαλυτερες να αυξανεται πιο εντονα. Μετα απο δοκιμες φαινεται μια ικανοποιητικη συναρτηση να ειναι η α * log(x/2) ^ (1/2) με α = 1.5  
.

Αρα **cost_assoc = 1.5 * log(assoc_size / 2) ^ (1/2)**

### Cache Line Size


Οπως ειδαμε και στα διαγραμματα των προσωμοιωσεων η αλλαγη του cache line size επιφερει τις μεγαλυτερες αλλαγες στο cpi και execution time των benchmarks. Ωστοσο αυτη η αλλαγη ειαι αρκετα ακριβη διαδικασια και για αυτο θα εχει υψηλο συντελεστη κοστους στην τελικη συναρτηση . 



### Cost Function 


Με βαση τα παραπανω η τελικη συναρτηση κοστους ειναι η : 


Cost = 8 * costL1d/32 + 8 * costL1i/32 + 4 * costL2 /2 + 1.5(log(assocL1d_size / 2) ^ (1/2) + log(assocL1i_size / 2) ^ (1/2) + log(assocL2_size / 2) ^ (1/2)) + 10 * cache_line_size/32 

Λαμβανοντας υποψιν το κοστος καθως και την θεωρια πισω απ την λειτουργια των caches καταληγουμε οτι :

- L1d = L1i = 32 kb ωστε να μειωσουμε το latency καθως και το κοστος
- L2 = 4 MB ωστε να ειναι αρκετα μεγαλη για να ανταποκρινεται στα περισσοτερα l1 misses που θα εχουμε λογω του tradeoff του μεγεθους της.
- assocL1d = assocL1i = 4
- Cache Line Size = 64 kb ωστε και να εχουμε ικανοποιητικη αυξηση της αποδοσης αλλα και να μην μεγαλωσουμε υπερογκα το κοστος.

τελικα Cost = 56 μοναδες κοστους



<br>

<br>


## Κριτική 







