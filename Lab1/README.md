# Εργασία Πρώτου Εργαστηρίου *Αρχιτεκτονικής Υπολογιστών*.

# ΤΗΜΜΥ 2020-2021

## Συγγραφείς: 
>- **Κινούς Αλέξανδρος**
>    >
>    > ***ΑΕΜ: 8834***
>
>- **Βαλαώρα Βασιλεία**
>    >
>    > ***ΑΕΜ:***

## Περιεχόμενα:
> 1. [Καταγραφή βασικών χαρακτηριστικών του συστήματος που μελετάμε, μέσω του αρχείου **starter_se.py**.1](#1-system-configuration)
>
> 2. Μελέτη καταγεγραμμένων στατιστικών του συστήματος μετα απο την εκτέλεση βασικόυ προγράμματος (*hello world*)
>
>    > a) [Επαλήθευση των χαρακτηριστικών του **ερωτήματος 1** μέσω των αρχείων **config.ini** *και* **config.json**.](#2a-config-files)
>    >
>    > b) [Aνάλυση των **commited instructions** που προσομοιώθηκαν.](#2b-commited-instructions)
>    >
>    > c) Μελέτη των προσπελάσεων στην **l2 CACHE** που συνέβησαν.
> 3. Εισαγωγή διαφορετικών μοντέλων ***in-order cpu*** ,benchmarks σε *δικο μας* πρόγραμμα και [πληροφορίες για τα μοντέλα cpu του gem5](#3-διαφορετικά-μοντέλα-in-order-cpu).
>
>    > a) Εκτέλεση του εν λόγω προγράμματος σε **TimingSimpleCPU** , **MinorCPU** και σύγκριση αποτελεσμάτων.
>    >
>    > b) Ερμηνεία των αποτελεσμάτων **βάση** των διαφορών των *δύο παραπάνω μοντέλων*.
>    >
>    > c) Αλλαγή παραμέτρων **CPU**,**Memory** στο ίδιο μοντέλο και σύγκριση αποτελεσμάτων.
>   
> 4. Κριτική Εργασίας.


## 1. System Configuration

Η βασική διαμόρφωση του συστήματος μας βρίσκεται στην **main** συνάρτηση του αρχείου **starter_se.py**.

Όταν εκτελέσαμε την εντολή:

`./build/ARM/gem5.opt configs/example/arm/starter_se.py --cpu-type="minor" "tests/test-progs/hello/bin/arm/linux/hello"`

Kρατήσαμε ολες τις **default** παραμέτρους ίδιες εκτός απο τον τυπο του cpu που απο **AtomicSimpleCpu** τον αλλάξαμε σε **MinorCpu** , χρησιμοποιόντας το flag: **--cpu-type="minor"**.

   -  **CPU Model** : Minor CPU
   -  **CPU Frequency** : 4Ghz
   -  **Number Of Cores** : 1
   -  **Memory Type** : DDR3 @ 1600 MHz 8x8 configuration
   -  **Memory Channels** : 2
   -  **Memory Size** : 2 GB
   -  **Cache Line Size** : 64 B

## 2a. Config Files

Σε αυτό το ερώτημα χρησιμοποιούμε τα αρχεία διαμόρφωσης **config.ini** και **config.json** για να επιβεβαιώσουμε τις [παραμέτρους](#1-system-configuration) που βρήκαμε εντός του **starter_se.py**.

Παρακάτω παραθέτουμε έναν πίνακα που αντιστοιχίζει τις γραμμές του αρχείου **config.ini** με τις παραπάνω παραμέτρους :


| Line |    Parameter    |     Comments     |
| --- | --- | --- |
| 65 | `type=MinorCPU` | Επιβεβαιώνεται οτι ο τύπος της cpu που χρησιμοποιούμαι ειναι η MinorCPU |
| 58 | `clock=250` | Υπονοείται 250 ns και κατα συνέπεια 4 GHz |
| 1405 <br> 1411| `banks_per_rank=8` <br> `device_bus_width=8` |  Επιβεβαιώνετε το 8X8 configuration της DDR3 μνήμης που χρησιμοποιήσαμε |
| 21 | `mem_ranges=0:2147483648` | 2^31 bytes αρα 2 GB μέγεθος μνήμης |
| 15 | `cache_line_size=64` | Διαπιστώνουμε και την τελική επιβεβαίωση του μεγέθους της cache line |

## 2b. Commited Instructions

Μελετώντας το αρχείο **stats.txt** βρισκουμε στις γραμμες **473** και **474** τα πεδία `Number of Instructions committed` και `Number of Ops committed` αντίστοιχα.

Όμως παρατηρούμε οτι ο αριθμός των commited εντολών ειναι 5028 ***ΑΛΛΑ*** των commited operations 5834.

Αμέσως δημιουργείται η εύλογη απορία σε τι οφείλεται η προαναφερθέισα αρκετά μεγάλη διαφορά.Για να λύσουμε αυτό το ζήτημα θα μελετήσουμε το pipeline του MinorCPU.

### MinorCPU PIPELINE
    
> - Fetch 1 :
>  
>    > Μονάδα υπεύθηνη για την λήψη cache lines απο το ICache Interface.
>
> - Fetch 2 :
>
>    > Ανάλυση των cache lines σε instructions.
>
> - Decode :
>
>    > Περαιτέρω αποσύνθεση των instructions σε micro operations.
>
> - Execute :
>    > Εκτέλεση των micro operations.

Εύκολα γινεται αντιληπτό απο το παραπάνω διάγραμμα οτι ο αριθμός των **micro ops** ειναι σαφώς μεγαλύτερος του αριθμού των **instructions** και συνεπώς ο αριθμός των **commited operations** (που περιεχει και τα micro operations) θα ειναι μεγαλύτερος απο τον αριθμό των **commited instuctions**.


## 2c. L2 Cache Access

θα μελετηθει αργοτερα..




## 3. Διαφορετικά μοντέλα in-order CPU.

### SimpleCPU

> Το **SimpleCPU** αποτελεί ένα πολύ απλό στην υλοποίηση in order μοντέλο κατασκευασμένο για χρήση σε απλά τεστ , όπου δεν είναι απαραίτητη η χρήση κάποιου πιο περίπλοκου μοντέλου.

### ΑtomicSimpleCPU

> Το **AtomicSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *atomic*. Αυτό σημαίνει ότι υπολογίζει προσεγγιστικά τον χρόνο
> πρόσβασης στην cache από τις χρονικές προσεγγίσεις των atomic accesses οι οποίες επιστρέφουν μια προσέγγιση του χρόνου που θα χρειαστούν για το access , ενώ η επιστροφή τιμής
> γίνεται στο τέλος του access function. Με αυτό τον τρόπο αποφεύγεται το queuing delay και το resource contention διότι η cpu γνωρίζει προσεγγιστικά τον χρόνο πρόσβασης στην
> μνήμη πριν αυτή ολοκληρωθεί.

### TimingSimpleCPU

> Το **TimingSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *timing*. Αυτό σημαίνει ότι σε κάθε πρόσβαση στην cache
> καθυστερεί και περιμένει την απάντηση από το σύστημα μνήμης πριν συνεχίσει την εκτέλεση εντολών ,υπάρχει δηλαδή **resource contention** και **queuing delay** , αφού ο
> επεξεργαστής περιμένει την ολοκλήρωση της πρόσβασης στην μνήμη για να συνεχίσει.

### MinorCPU

> Το **MinorCPU** μοντέλο αποτελεί ένα *in-order* μοντέλο με συγκεκριμένο pipeline `Fetch1-Fetch2-Decode-Execute` όπως είδαμε και παραπάνω αλλά προσαρμοζόμενα *data structures*
> και προσαρμοζόμενη συμπεριφορά εκτέλεσης. Το σταθερό pipeline του βοηθάει στην αναγνώριση και οπτικοποίηση μέσα σε αυτό της κάθε εντολής από μία προσομοίωση. 



## 3a. Benchmarks δικού μας προγράμματος σε TimingSimpleCPU και MinorCPU.

Για τις ανάγκες αυτού του ερωτήματος υλοποιήθηκε δικό μας προγραμμα `oddnums.c` που υπολογίζει και τυπώνει τους περιττούς αριθμούς απο το 0 εως το 1000.

Τα αποτελέσματα χρόνου εκτέλεσης **sim_seconds** στα δύο διαφορετικά *μοντέλα* κρατώντας τις υπόλοιπες παραμέτρους default παρατίθενται παρακάτω:

- **MinorCPU**
    > 0.000334 s 
- **TimingSimpleCPU**
    > 0.000644 s


    
  
