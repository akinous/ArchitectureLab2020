# Εργασία Πρώτου Εργαστηρίου _Αρχιτεκτονικής Υπολογιστών_.

# ΤΗΜΜΥ 2020-2021

## Συγγραφείς: 
- **Κινούς Αλέξανδρος**  
***ΑΕΜ: 8834***

- **Βαλαώρα Βασιλεία**  
***ΑΕΜ: 8657***

## Περιεχόμενα:
> 1. [Εντοπισμός βασικών παραμέτρων του συστήματος προς εξομοίωση, μέσω του αρχείου **starter_se.py**.1](#1-system-configuration)
>
> 2. Μελέτη καταγεγραμμένων στατιστικών του συστήματος μετά από την εκτέλεση βασικού προγράμματος (*hello world*)
>
>    > a) [Επαλήθευση των χαρακτηριστικών του **ερωτήματος 1** μέσω των αρχείων **config.ini** *και* **config.json**.](#2a-config-files)
>    >
>    > b) [Aνάλυση των **commited instructions** που προσομοιώθηκαν.](#2b-commited-instructions)
>    >
>    > c) [Μελέτη των προσπελάσεων στην **L2 CACHE** που συνέβησαν](#2c-l2-cache-access).
> 3. Εισαγωγή διαφορετικών μοντέλων ***in-order cpu*** ,benchmarks σε *δικο μας* πρόγραμμα και [πληροφορίες για τα μοντέλα cpu του gem5](#3-διαφορετικά-μοντέλα-in-order-cpu).
>
>    > a) [Εκτέλεση του εν λόγω προγράμματος σε **TimingSimpleCPU** , **MinorCPU** και σύγκριση αποτελεσμάτων](#3a-benchmarks-δικού-μας-προγράμματος-σε-timingsimplecpu-και-minorcpu).
>    >
>    > b) [Ερμηνεία των αποτελεσμάτων **βάσει** των διαφορών των *δύο παραπάνω μοντέλων*](#3b-ερμηνεία-των-παραπάνω-αποτελεσμάτων).
>    >
>    > c) [Αλλαγή παραμέτρων **CPU**,**Memory** στο ίδιο μοντέλο και σύγκριση αποτελεσμάτων](#3c-αλλαγή-παραμέτρων-cpu-μνήμης-και-ερμηνεία-αποτελεσμάτων).
>   
> 4. [Κριτική Εργασίας](#κριτική-εργασίας).
>
> 5. [Πηγές](#πηγές)


## 1. System Configuration

Η βασική διαμόρφωση του συστήματός μας ορίζεται στην **main** συνάρτηση του αρχείου **starter_se.py**.

Όταν εκτελέσαμε την εντολή:

`./build/ARM/gem5.opt configs/example/arm/starter_se.py --cpu-type="minor" "tests/test-progs/hello/bin/arm/linux/hello"`

Kρατήσαμε όλες τις **default** παραμέτρους ίδιες εκτός από τον τύπο του cpu που από **AtomicSimpleCpu** τον αλλάξαμε σε **MinorCpu**, χρησιμοποιώντας το flag: **--cpu-type="minor"**.

   -  **CPU Model** : Minor CPU
   -  **CPU Frequency** : 4Ghz
   -  **Number Of Cores** : 1
   -  **Memory Type** : DDR3 @ 1600 MHz 8x8 configuration
   -  **Memory Channels** : 2
   -  **Memory Size** : 2 GB
   -  **Cache Line Size** : 64 B

## 2a. Config Files

Σε αυτό το ερώτημα χρησιμοποιούμε τα αρχεία διαμόρφωσης **config.ini** και **config.json** για να επιβεβαιώσουμε τις [παραμέτρους](#1-system-configuration) που βρήκαμε εντός του **starter_se.py**.

Παρακάτω παραθέτουμε έναν πίνακα που αντιστοιχίζει τις γραμμές του αρχείου **config.ini** με τις παραπάνω παραμέτρους :


| Line |    Parameter    |     Comments     |
| --- | --- | --- |
| 65 | `type=MinorCPU` | Επιβεβαιώνεται οτι ο τύπος της cpu που χρησιμοποιούμε ειναι η MinorCPU |
| 58 | `clock=250` | Υπονοείται 250 ns και κατά συνέπεια 4 GHz |
| 1405 <br> 1411| `banks_per_rank=8` <br> `device_bus_width=8` |  Επιβεβαιώνετε το 8X8 configuration της DDR3 μνήμης που χρησιμοποιήσαμε |
| 21 | `mem_ranges=0:2147483648` | 2^31 bytes αρα 2 GB μέγεθος μνήμης |
| 15 | `cache_line_size=64` | Διαπιστώνουμε και την τελική επιβεβαίωση του μεγέθους της cache line |

## 2b. Commited Instructions

Μελετώντας το αρχείο **stats.txt** εντοπίζουμε στις γραμμές **473** και **474** τα πεδία `Number of Instructions committed` και `Number of Ops committed` αντίστοιχα.

Όμως παρατηρούμε ότι ο αριθμός των commited εντολών ειναι 5028 ***ΑΛΛΑ*** των commited operations 5834.

Αμέσως δημιουργείται η εύλογη απορία σε τι οφείλεται η προαναφερθείσα αρκετά μεγάλη διαφορά. Για να επιλύσουμε αυτό το ζήτημα θα μελετήσουμε το pipeline του MinorCPU.

### MinorCPU PIPELINE
    
> - Fetch 1 :
>  
>    > Μονάδα υπεύθηνη για την λήψη cache lines απο το ICache Interface.
>
> - Fetch 2 :
>
>    > Ανάλυση των cache lines σε instructions.
>
> - Decode :
>
>    > Περαιτέρω αποσύνθεση των instructions σε micro operations.
>
> - Execute :
>    > Εκτέλεση των micro operations.

Εύκολα γινεται αντιληπτό από το παραπάνω διάγραμμα ότι ο αριθμός των **micro ops** ειναι σαφώς μεγαλύτερος του αριθμού των **instructions** και συνεπώς ο αριθμός των **commited operations** (που περιέχει και τα micro operations) θα είναι μεγαλύτερος από τον αριθμό των **commited instuctions**.


## 2c. L2 Cache Access

θα μελετηθει αργοτερα..




## 3. Διαφορετικά μοντέλα in-order CPU

### SimpleCPU

> Το **SimpleCPU** αποτελεί ένα πολύ απλό στην υλοποίηση in order μοντέλο κατασκευασμένο για χρήση σε απλά τεστ , όπου δεν είναι απαραίτητη η χρήση κάποιου πιο περίπλοκου μοντέλου.

### ΑtomicSimpleCPU

> Το **AtomicSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *atomic*. Αυτό σημαίνει ότι υπολογίζει προσεγγιστικά τον χρόνο πρόσβασης στην cache από τις χρονικές προσεγγίσεις των atomic accesses οι οποίες επιστρέφουν μια προσέγγιση του χρόνου που θα χρειαστούν για το access, ενώ η επιστροφή τιμής γίνεται στο τέλος του access function. Με αυτό τον τρόπο αποφεύγεται το queuing delay και το resource contention, διότι η cpu γνωρίζει προσεγγιστικά τον χρόνο πρόσβασης στην μνήμη πριν αυτή ολοκληρωθεί.

### TimingSimpleCPU

> Το **TimingSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *timing*. Αυτό σημαίνει ότι σε κάθε πρόσβαση στην cache καθυστερεί και περιμένει την απάντηση από το σύστημα μνήμης πριν συνεχίσει την εκτέλεση εντολών, υπάρχει δηλαδή **resource contention** και **queuing delay**, αφού ο επεξεργαστής περιμένει την ολοκλήρωση της πρόσβασης στην μνήμη για να συνεχίσει.

### MinorCPU

> Το **MinorCPU** μοντέλο αποτελεί ένα *in-order* μοντέλο με συγκεκριμένο pipeline `Fetch1-Fetch2-Decode-Execute`, όπως είδαμε και παραπάνω, αλλά προσαρμοζόμενα *data structures* και προσαρμοζόμενη συμπεριφορά εκτέλεσης. Το σταθερό pipeline που το χαρακτηρίζει, βοηθάει στην αναγνώριση και οπτικοποίηση μέσα σε αυτό της κάθε εντολής από μία προσομοίωση. 



## 3a. Benchmarks δικού μας προγράμματος σε TimingSimpleCPU και MinorCPU

Για τις ανάγκες αυτού του ερωτήματος υλοποιήθηκε δικό μας πρόγραμμα `oddnums.c`, που υπολογίζει και τυπώνει τους περιττούς αριθμούς απο το 0 εως το 1000.

Τα αποτελέσματα χρόνου εκτέλεσης **sim_seconds** στα δύο διαφορετικά *μοντέλα* κρατώντας τις υπόλοιπες παραμέτρους default παρατίθενται παρακάτω:

- **MinorCPU**
    > 0.000334 s 
- **TimingSimpleCPU**
    > 0.000644 s


## 3b. Ερμηνεία των παραπάνω αποτελεσμάτων

Παρατηρούμε ότι η διαφορά του *χρόνου υλοποίησης* στα δύο μοντέλα είναι ιδιαίτερα αισθητή (περίπου διπλάσια). 

Όπως είδαμε πολλάκις παραπάνω, το **MinorCPU** λειτουργεί με το γνωστό [***pipeline***](#minorcpu-pipeline) το οποίο επιτρέπει στον επεξεργαστή να εκτελεί παράλληλα διεργασίες. Πέραν τούτου, η "απλοϊκότητα" του προγράμματος που εκτελέστηκε βοήθησε τον MinorCPU να είναι έξτρα αποδοτικός.

Αντίθετα το **TimingSimpleCPU** εκτελεί πιο λεπτομερώς το εκάστοτε πρόγραμμα ενώ παράλληλα εμπεριέχει όλες τις χρονικές καθυστερήσεις που θα συνέβαιναν σε ένα ρεαλιστίκο σενάριο. Αυτή η αναμονή για την απόκριση του συστήματος εως ότου να εκτελέσει το επομενο *instruction* καθυστερέι την συνολική διαδικασία.


## 3c. Αλλαγή παραμέτρων CPU, μνήμης και ερμηνεία αποτελεσμάτων

### Αρχικά αλλάξαμε το ρολόι στα 2GHz και 5GHz αντίστοιχα, και μετρήσαμε τους χρόνους εκτέλεσης.

| CPU clock | CPU type | Simulation Seconds (σε ms) |
| --- | --- | --- |
| 1 GHz | Minor | 0.334 |
| 2 GHz | Minor | 0.320 |
| 5 GHz | Minor | 0.313 |
| 1 GHz | TimingSimple | 0.644 |
| 2 GHz | TimingSimple | 0.642 |
| 5 GHz | TimingSImple | 0.640 |

Όπως βλέπουμε η επιτάχυνση της **TimingSimpleCPU** από το 1GHz στα 5GHz είναι ελάχιστη και συγκεκριμένα ***0.62%***, καθώς, όπως προαναφέραμε, το μοντέλο περιορίζεται από τις αργές προσβάσεις στην μνήμη. Στην περίπτωση τώρα του μοντέλου **MinorCPU** η αύξηση είναι πολύ μεγαλύτερη ***6%***, επειδή με την αύξηση του ρολογιού επιταχύνονται τα στάδια του [**pipeline**](#minorcpu-pipeline) που δεν αφορούν προσβάσεις σε μνήμη.



### Στη συνέχεια διατηρούμε το ρολόι στο 1GHz και αλλάζουμε τον τύπο της μνήμης.

| Memory Type | CPU type | Simulation Seconds (σε ms) |
| --- | --- | --- |
| DDR3_1600_8x8 | Minor | 0.334 |
| DDR4_2400_8x8 | Minor | 0.334 |
| HMC_2500_1x32 | Minor | 0.334 |
| DDR3_1600_8x8 | TimingSimple | 0.644 |
| DDR4_2400_8x8 | TimingSimple | 0.644 |
| HMC_2500_1x32 | TimingSimple | 0.644 |

Θα περιμέναμε ότι οι αλλαγές στην *τεχνολογία* της μνήμης θα επιφέρανε και αλλαγές στον *χρόνο εκτέλεσης* (γρηγορότερη μνήμη = γρηγορότερες προσβάσεις στη μνήμη = γρηγορότερη εκτέλεση). Κάτι το οποίο δεν συμβαίνει όπως βλέπουμε και στον παραπάνω πίνακα. Πιθανολογούμε οτι αυτό συμβαίνει διότι το πρόγραμμα μας είναι αρκετά απλό, ώστε όλες οι προσβάσεις να γίνονται στην μνήμη **cache** και οι προσβάσεις στην **κύρια μνήμη** να είναι ελάχιστες.



## Κριτική Εργασίας

Το σημαντικότερο κομμάτι της εργασίας ηταν σίγουρα η εξοικείωση με το περιβάλλον **github** και την γλώσσα **markdown** . Μας έβαλε επίσης στην διαδικασία να μπορούμε να προσεγγίσουμε ένα "κακογραμμένο" **documentation** (δηλαδή αυτό του gem5) και να αναζητούμε πληροφορίες για πολύ εξειδικευμένα προγράμματα και τεχνολογίες. Επίσης, μπήκαμε στην λογική να μην ακολουθούμε τυφλά οδηγίες, διότι με την προτεινόμενη μέθοδο εγκατάστασης προκύπτανε πολλαπλά προβλήματα τα οποία έπρεπε να ξεπεράσουμε. Συνολικά, ηταν μια αρκετά ενδιαφέρουσα εμπειρία με τα θετικά της και τα αρνητικά της!




## Πηγές

[Gem5 Official Documentation](https://www.gem5.org/)

[Gem5 Secondary Documentation](http://pages.cs.wisc.edu/~swilson/gem5-docs/index.html)







    
  
