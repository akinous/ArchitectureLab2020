# Εργασία Πρώτου Εργαστηρίου *Αρχιτεκτονικής Υπολογιστών*.

# ΤΗΜΜΥ 2020-2021

## Συγγραφείς: 
>- **Κινούς Αλέξανδρος**
>    >
>    > ***ΑΕΜ: 8834***
>
>- **Βαλαώρα Βασιλεία**
>    >
>    > ***ΑΕΜ:***

## Περιεχόμενα:
> 1. [Καταγραφή βασικών χαρακτηριστικών του συστήματος που μελετάμε, μέσω του αρχείου **starter_se.py**.1](#1-system-configuration)
>
> 2. Μελέτη καταγεγραμμένων στατιστικών του συστήματος μετα απο την εκτέλεση βασικόυ προγράμματος (*hello world*)
>
>    > a) [Επαλήθευση των χαρακτηριστικών του **ερωτήματος 1** μέσω των αρχείων **config.ini** *και* **config.json**.](#2a-config-files)
>    >
>    > b) [Aνάλυση των **commited instructions** που προσομοιώθηκαν.](#2b-commited-instructions)
>    >
>    > c) Μελέτη των προσπελάσεων στην **l2 CACHE** που συνέβησαν.
> 3. Εισαγωγή διαφορετικών μοντέλων ***in-order cpu*** ,benchmarks σε *δικο μας* πρόγραμμα και [πληροφορίες για τα μοντέλα cpu του gem5](#3-διαφορετικά-μοντέλα-in-order-cpu).
>
>    > a) [Εκτέλεση του εν λόγω προγράμματος σε **TimingSimpleCPU** , **MinorCPU** και σύγκριση αποτελεσμάτων](#3a-benchmarks-δικού-μας-προγράμματος-σε-timingsimplecpu-και-minorcpu).
>    >
>    > b) [Ερμηνεία των αποτελεσμάτων **βάση** των διαφορών των *δύο παραπάνω μοντέλων*](#3b-ερμηνεία-των-παραπάνω-αποτελεσμάτων).
>    >
>    > c) [Αλλαγή παραμέτρων **CPU**,**Memory** στο ίδιο μοντέλο και σύγκριση αποτελεσμάτων](#3c-αλλαγή-παραμέτρων-cpu-μνήμης-και-ερμηνεία-αποτελεσμάτων).
>   
> 4. [Κριτική Εργασίας](#κριτική-εργασίας).
>
> 5. [Πηγές](#πηγές)


## 1. System Configuration

Η βασική διαμόρφωση του συστήματος μας βρίσκεται στην **main** συνάρτηση του αρχείου **starter_se.py**.

Όταν εκτελέσαμε την εντολή:

`./build/ARM/gem5.opt configs/example/arm/starter_se.py --cpu-type="minor" "tests/test-progs/hello/bin/arm/linux/hello"`

Kρατήσαμε ολες τις **default** παραμέτρους ίδιες εκτός απο τον τυπο του cpu που απο **AtomicSimpleCpu** τον αλλάξαμε σε **MinorCpu** , χρησιμοποιόντας το flag: **--cpu-type="minor"**.

   -  **CPU Model** : Minor CPU
   -  **CPU Frequency** : 4Ghz
   -  **Number Of Cores** : 1
   -  **Memory Type** : DDR3 @ 1600 MHz 8x8 configuration
   -  **Memory Channels** : 2
   -  **Memory Size** : 2 GB
   -  **Cache Line Size** : 64 B

## 2a. Config Files

Σε αυτό το ερώτημα χρησιμοποιούμε τα αρχεία διαμόρφωσης **config.ini** και **config.json** για να επιβεβαιώσουμε τις [παραμέτρους](#1-system-configuration) που βρήκαμε εντός του **starter_se.py**.

Παρακάτω παραθέτουμε έναν πίνακα που αντιστοιχίζει τις γραμμές του αρχείου **config.ini** με τις παραπάνω παραμέτρους :


| Line |    Parameter    |     Comments     |
| --- | --- | --- |
| 65 | `type=MinorCPU` | Επιβεβαιώνεται οτι ο τύπος της cpu που χρησιμοποιούμαι ειναι η MinorCPU |
| 58 | `clock=250` | Υπονοείται 250 ns και κατα συνέπεια 4 GHz |
| 1405 <br> 1411| `banks_per_rank=8` <br> `device_bus_width=8` |  Επιβεβαιώνετε το 8X8 configuration της DDR3 μνήμης που χρησιμοποιήσαμε |
| 21 | `mem_ranges=0:2147483648` | 2^31 bytes αρα 2 GB μέγεθος μνήμης |
| 15 | `cache_line_size=64` | Διαπιστώνουμε και την τελική επιβεβαίωση του μεγέθους της cache line |

## 2b. Commited Instructions

Μελετώντας το αρχείο **stats.txt** βρισκουμε στις γραμμες **473** και **474** τα πεδία `Number of Instructions committed` και `Number of Ops committed` αντίστοιχα.

Όμως παρατηρούμε οτι ο αριθμός των commited εντολών ειναι 5028 ***ΑΛΛΑ*** των commited operations 5834.

Αμέσως δημιουργείται η εύλογη απορία σε τι οφείλεται η προαναφερθέισα αρκετά μεγάλη διαφορά.Για να λύσουμε αυτό το ζήτημα θα μελετήσουμε το pipeline του MinorCPU.

### MinorCPU PIPELINE
    
> - Fetch 1 :
>  
>    > Μονάδα υπεύθηνη για την λήψη cache lines απο το ICache Interface.
>
> - Fetch 2 :
>
>    > Ανάλυση των cache lines σε instructions.
>
> - Decode :
>
>    > Περαιτέρω αποσύνθεση των instructions σε micro operations.
>
> - Execute :
>    > Εκτέλεση των micro operations.

Εύκολα γινεται αντιληπτό απο το παραπάνω διάγραμμα οτι ο αριθμός των **micro ops** ειναι σαφώς μεγαλύτερος του αριθμού των **instructions** και συνεπώς ο αριθμός των **commited operations** (που περιεχει και τα micro operations) θα ειναι μεγαλύτερος απο τον αριθμό των **commited instuctions**.


## 2c. L2 Cache Access

θα μελετηθει αργοτερα..




## 3. Διαφορετικά μοντέλα in-order CPU.

### SimpleCPU

> Το **SimpleCPU** αποτελεί ένα πολύ απλό στην υλοποίηση in order μοντέλο κατασκευασμένο για χρήση σε απλά τεστ , όπου δεν είναι απαραίτητη η χρήση κάποιου πιο περίπλοκου μοντέλου.

### ΑtomicSimpleCPU

> Το **AtomicSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *atomic*. Αυτό σημαίνει ότι υπολογίζει προσεγγιστικά τον χρόνο
> πρόσβασης στην cache από τις χρονικές προσεγγίσεις των atomic accesses οι οποίες επιστρέφουν μια προσέγγιση του χρόνου που θα χρειαστούν για το access , ενώ η επιστροφή τιμής
> γίνεται στο τέλος του access function. Με αυτό τον τρόπο αποφεύγεται το queuing delay και το resource contention διότι η cpu γνωρίζει προσεγγιστικά τον χρόνο πρόσβασης στην
> μνήμη πριν αυτή ολοκληρωθεί.

### TimingSimpleCPU

> Το **TimingSimpleCPU** αποτελεί υλοποίηση του **SimpleCPU** μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου *timing*. Αυτό σημαίνει ότι σε κάθε πρόσβαση στην cache
> καθυστερεί και περιμένει την απάντηση από το σύστημα μνήμης πριν συνεχίσει την εκτέλεση εντολών ,υπάρχει δηλαδή **resource contention** και **queuing delay** , αφού ο
> επεξεργαστής περιμένει την ολοκλήρωση της πρόσβασης στην μνήμη για να συνεχίσει.

### MinorCPU

> Το **MinorCPU** μοντέλο αποτελεί ένα *in-order* μοντέλο με συγκεκριμένο pipeline `Fetch1-Fetch2-Decode-Execute` όπως είδαμε και παραπάνω αλλά προσαρμοζόμενα *data structures*
> και προσαρμοζόμενη συμπεριφορά εκτέλεσης. Το σταθερό pipeline του βοηθάει στην αναγνώριση και οπτικοποίηση μέσα σε αυτό της κάθε εντολής από μία προσομοίωση. 



## 3a. Benchmarks δικού μας προγράμματος σε TimingSimpleCPU και MinorCPU.

Για τις ανάγκες αυτού του ερωτήματος υλοποιήθηκε δικό μας προγραμμα `oddnums.c` που υπολογίζει και τυπώνει τους περιττούς αριθμούς απο το 0 εως το 1000.

Τα αποτελέσματα χρόνου εκτέλεσης **sim_seconds** στα δύο διαφορετικά *μοντέλα* κρατώντας τις υπόλοιπες παραμέτρους default παρατίθενται παρακάτω:

- **MinorCPU**
    > 0.000334 s 
- **TimingSimpleCPU**
    > 0.000644 s


## 3b. Ερμηνεία των παραπάνω αποτελεσμάτων.

Παρατηρούμε οτι η διαφορά του *χρόνου υλοποίησης* στα δύο μοντέλα ειναι ιδιαίτερα αισθητή (περίπου διπλάσια). 

Όπως είδαμε πολλάκις παραπάνω το **MinorCPU** λειτουργεί με το γνωστό [***pipeline***](#minorcpu-pipeline) το οποίο επιτρέπει στον επεξεργαστκή να εκτελεί παράλληλα διεργασίες. Πέραν τούτου η απλοικότητα του προγράμματος που εκτελέστηκε βοήθησε τον MinorCPU να είναι έξτρα αποδοτικός.

Αντίθετα το **TimingSimpleCPU** εκτελεί πιο λεπτομερώς το εκάστοτε πρόγραμμα ενώ παράλληλα εμπεριέχει όλες τις χρονικές καθυστερήσεις που θα συνέβαιναν σε ένα ρεαλιστίκο σενάριο. Αυτή η αναμονή για την απόκριση του συστήματος εως ότου να εκτελέσει το επομενο *instruction* καθυστερέι την συνολική διαδικασία.


## 3c. Αλλαγή παραμέτρων CPU ,μνήμης και ερμηνεία αποτελεσμάτων.

### Αρχικά αλλάξαμε το ρολόι στα 2GHz και 5GHz αντίστοιχα και μετρήσαμε τους χρόνους εκτέλεσης

| CPU clock | CPU type | Simulation Seconds (σε ms) |
| --- | --- | --- |
| 1 GHz | Minor | 0.334 |
| 2 GHz | Minor | 0.320 |
| 5 GHz | Minor | 0.313 |
| 1 GHz | TimingSimple | 0.644 |
| 2 GHz | TimingSimple | 0.642 |
| 5 GHz | TimingSImple | 0.640 |

Όπως βλέπουμε η επιτάχυνση της **TimingSimpleCPU** απο το 1GHz στα 5GHz ειναι ελάχιστη και συγκεκριμένα ***0.62%*** καθώς όπως προαναφέραμε το μοντέλο περιορίζεται απο τις αργές προσβάσεις στην μνήμη. Στην περίπτωση τώρα του μοντέλου **MinorCPU** η αύξηση ειναι πολυ μεγαλύτερη ***6%*** επειδή με την αύξηση του ρολογιού επιταχύνονται τα στάδια του [**pipeline**](#minorcpu-pipeline) που δεν αφορούν προσβάσεις σε μνήμη.



### Στη συνέχεια διατηρούμε το ρολοί στο 1GHz και αλλάζουμε τον τύπο της μνήμης.

| Memory Type | CPU type | Simulation Seconds (σε ms) |
| --- | --- | --- |
| DDR3_1600_8x8 | Minor | 0.334 |
| DDR4_2400_8x8 | Minor | 0.334 |
| HMC_2500_1x32 | Minor | 0.334 |
| DDR3_1600_8x8 | TimingSimple | 0.644 |
| DDR4_2400_8x8 | TimingSimple | 0.644 |
| HMC_2500_1x32 | TimingSimple | 0.644 |

Θα περιμέναμε οτι αλλαγές στην *τεχνολογία* της μνήμης θα επιφέρανε και αλλαγές στον *χρόνο εκτέλεσης* (γρηγοροτερη μνήμη = γρηγορότερες προσβάσεις στη μνήμη = γρηγορότερη εκτέλεση). Κάτι το οποίο δεν συμβαίνει όπως βλέπουμε και στον παραπάνω πίνακα. Πιθανολογούμε οτι αυτό συμβαίνει διότι το πρόγραμμα μας ειναι αρκετά απλό ώστε όλες οι προσβάσεις να γίνονται στην μνήμη **cache** και οι προσβάσεις στην **κύρια μνήμη** ελάχιστες.



## Κριτική Εργασίας

Το σημαντικότερο κομματι της εργασίας ηταν σίγουρα η εξοικείωση με το περιβάλλον **github** και την γλώσσα **markdown** . Μας έβαλε επίσης στη διαδικασία να μπορούμε να προσεγγίσουμε ένα κακογραμμένο **documentation** (δηλαδή αυτό του gem5) και να αναζητούμε πληροφορίες για πολύ εξειδικευμένα προγράμματα και τεχνολογίες. Επίσης μπήκαμε στην λογική να μην ακολουθούμε τυφλά οδηγίες διότι με την προτεινόμενη μέθοδο εγκατάστασης προκύπτανε πολλαπλά προβλήματα τα οποία έπρεπε να ξεπεράσουμε. Συνολικά ηταν μια αρκετά ενδιαφέρουσα εμπειρία με τα θετικά της και τα αρνητικά της!




## Πηγές

[Gem5 Official Documentation](https://www.gem5.org/)

[Gem5 Secondary Documentation](http://pages.cs.wisc.edu/~swilson/gem5-docs/index.html)







    
  
